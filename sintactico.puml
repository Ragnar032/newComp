@startuml
title Proceso de Análisis Sintáctico (Parsing)

start
:main.py inicia con la `lista de tokens`;
:Crea una instancia de `Parser(tokens)`;
:Llama a `Parser.parse()`;

partition Parser {
    note right: El Parser hereda de GrammarRules y ParserAuxiliaries.
    
    :El método `parse()` llama a la regla inicial `parse_class_declaration()`;
    
    partition Descenso Recursivo (GrammarRules) {
        :<b>parse_class_declaration()</b>;
        :Llama a `eat('PUBLIC')`;
        :Llama a `eat('CLASS')`;
        :Guarda el nombre de la clase (ID);
        :Llama a `eat('LLAVE_IZQ')`;
        
        while (token actual no es 'LLAVE_DER'?) is (sí)
            :Llama a `parse_member_declaration()`;
            
            partition parse_member_declaration() {
                if (token es 'PUBLIC' o 'PRIVATE'?) then (sí)
                    :Llama a `parse_method_declaration()`;
                    note right: Esto a su vez llamará a `parse_block_statement()`, \nque llama a `parse_statement()`, \ny este a `parse_expression()`, etc.
                else (no)
                    :Llama a `parse_variable_declaration()`;
                endif
            }
            :Añade el nodo resultante al cuerpo de la clase;
        endwhile
        
        :Llama a `eat('LLAVE_DER')`;
        :Construye y retorna el nodo `DeclaracionClase` (el AST);
    }
    
    :El método `parse()` recibe el AST;
    :Verifica que el siguiente token sea 'EOF';
    :Realiza una validación simple (ej: existe el método main);
    :Retorna el `AST`;
}

:main.py recibe el `AST`;

stop
@enduml